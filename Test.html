<h1>Damage By Skill - Throne and Liberty</h1>

<div style="margin-top:4px;text-align:center;font-size:13px;">
  Logs folder:
  <code id="logPath" style="cursor:pointer;">%LOCALAPPDATA%\TL\SAVED\COMBATLOGS</code>
  <span id="copyMsg" style="margin-left:6px;font-size:12px;color:#aaa;"></span>
</div>

<p style="margin-top:16px;">Select one or more combatlog (.txt) files exported from the game.</p>

<input type="file" id="logFile" accept=".txt" multiple style="display:none;">
<div id="dropZone">Drop your combatlog (.txt) files here<br><span>or click to select them</span></div>
<div id="status"></div>

<div style="width:95%;max-width:1600px;margin-top:6px;text-align:right;">
  <button id="clearLogsBtn">Clear logs</button>
</div>

<div class="summary">
  <div class="card"><div class="card-title">Total Damage</div><div class="card-value" id="sumTotalDamage">0</div></div>
  <div class="card"><div class="card-title">Average DPS</div><div class="card-value" id="sumAvgDps">0</div></div>
  <div class="card"><div class="card-title">Players</div><div class="card-value" id="sumPlayers">0</div></div>
  <div class="card"><div class="card-title">Target</div><div class="card-value" id="sumBossName">---</div></div>
</div>

<div id="timeRangeWrapper">
  <div style="font-size:12px;color:#ccc;margin-bottom:4px;">
    Time range: <span id="timeRangeLabel">0s - 0s</span>
  </div>
  <div id="timeRangeSlider"></div>
</div>

<h2>Player Statistics</h2>
<p>Click one or more players to compare them on the charts. âœ• removes from logs completely.</p>

<table>
  <thead>
    <tr><th>#</th><th>Player</th><th>DPS</th><th>Total Damage</th><th>% Fight</th><th>Hits</th><th>Avg Hit</th><th>Max Hit</th><th>Duration</th><th></th></tr>
  </thead>
  <tbody id="playerBody"></tbody>
</table>

<div style="width:95%;max-width:1600px;margin-top:8px;text-align:right;">
  <button id="toggleTargetsBtn">Show other targets</button>
  <button id="togglePullsBtn">Show Boss Pulls</button>
</div>

<div id="targetsWrapper">
  <div id="targetsScroll">
    <table id="targetsTable">
      <thead><tr><th>Target</th><th>Total Damage</th><th>Hits</th></tr></thead>
      <tbody id="targetsBody"></tbody>
    </table>
  </div>
</div>

<div id="pullsWrapper">
  <h2 style="margin-top:26px;margin-bottom:6px;font-size:18px;font-weight:600;letter-spacing:.08em;text-transform:uppercase;color:#c5caf8;">Boss Pulls Detected</h2>
  <table id="pullsTable">
    <thead>
      <tr><th>#</th><th>Boss</th><th>Start</th><th>Duration</th><th>Total Damage</th><th>DPS</th><th>Status</th></tr>
    </thead>
    <tbody id="pullsBody"></tbody>
  </table>
</div>

<div class="panel">
  <div class="panel-header"><span class="panel-title">Damage By Skill</span><span class="panel-meta" id="playersMeta"></span></div>
  <div class="panel-body" id="chartContainer"><canvas id="damageChart"></canvas></div>
</div>

<div class="panel">
  <div class="panel-header"><span class="panel-title">Average DPS Over Time</span><span class="panel-meta" id="avgFightDurationMeta"></span></div>
  <div class="panel-body" id="avgTimelineContainer"><canvas id="avgDpsTimeline"></canvas></div>
</div>

<div id="avgControls">(Click and drag to zoom) <button id="resetAvgZoomBtn">Reset zoom</button></div>

<div class="panel">
  <div class="panel-header"><span class="panel-title">DPS Timeline (Per Second)</span><span class="panel-meta" id="fightDurationMeta"></span></div>
  <div class="panel-body" id="timelineContainer"><canvas id="dpsTimeline"></canvas></div>
</div>

const fileInput=document.getElementById('logFile'),
      dropZone=document.getElementById('dropZone'),
      statusEl=document.getElementById('status'),
      playerBody=document.getElementById('playerBody'),
      targetsTable=document.getElementById('targetsTable'),
      targetsBody=document.getElementById('targetsBody'),
      targetsWrapper=document.getElementById('targetsWrapper'),
      toggleTargetsBtn=document.getElementById('toggleTargetsBtn'),
      togglePullsBtn=document.getElementById('togglePullsBtn'),
      pullsBody=document.getElementById('pullsBody'),
      pullsWrapper=document.getElementById('pullsWrapper'),
      resetAvgZoomBtn=document.getElementById('resetAvgZoomBtn'),
      logPathEl=document.getElementById('logPath'),
      copyMsgEl=document.getElementById('copyMsg'),
      clearLogsBtn=document.getElementById('clearLogsBtn'),
      timeRangeLabel=document.getElementById('timeRangeLabel'),
      timeRangeSliderEl=document.getElementById('timeRangeSlider');

let skillChart,dpsTimelineChart,avgDpsTimelineChart;
let playersData=[],selectedPlayers=[],selectedTarget=null;
let globalBossPhases=[],timeSlider=null;
let timeFilter={from:0,to:null};

const BAR_COLORS=['rgba(88,101,242,.8)','rgba(46,204,113,.8)','rgba(231,76,60,.8)','rgba(241,196,15,.8)','rgba(155,89,182,.8)','rgba(26,188,156,.8)','rgba(230,126,34,.8)','rgba(149,165,166,.8)'],
      BAR_BORDER_COLORS=['rgba(88,101,242,1)','rgba(46,204,113,1)','rgba(231,76,60,1)','rgba(241,196,15,1)','rgba(155,89,182,1)','rgba(26,188,156,1)','rgba(230,126,34,1)','rgba(149,165,166,1)'],
      LINE_COLORS=['rgba(255,99,132,1)','rgba(54,162,235,1)','rgba(75,192,192,1)','rgba(255,206,86,1)','rgba(153,102,255,1)','rgba(255,159,64,1)','rgba(46,204,113,1)','rgba(231,76,60,1)','rgba(52,152,219,1)','rgba(241,196,15,1)'];

const getColorForIndex=i=>({
  rowBg:BAR_COLORS[i%BAR_COLORS.length],
  text:'#fff',
  barBg:BAR_COLORS[i%BAR_COLORS.length],
  barBorder:BAR_BORDER_COLORS[i%BAR_BORDER_COLORS.length],
  line:LINE_COLORS[i%LINE_COLORS.length]
});

logPathEl.onclick=()=>{navigator.clipboard.writeText('%LOCALAPPDATA%\\TL\\SAVED\\COMBATLOGS').then(()=>{copyMsgEl.textContent='Path copied âœ”';setTimeout(()=>copyMsgEl.textContent='',2000);});};

dropZone.onclick=()=>fileInput.click();
dropZone.ondragover=e=>{e.preventDefault();dropZone.style.borderColor='#4fd1ff';dropZone.style.background='#15172a';};
dropZone.ondragleave=e=>{e.preventDefault();dropZone.style.borderColor='#5865F2';dropZone.style.background='#10111b';};
dropZone.ondrop=e=>{e.preventDefault();dropZone.style.borderColor='#5865F2';dropZone.style.background='#10111b';const f=e.dataTransfer.files;if(!f.length)return;fileInput.files=f;handleFiles();};

const parseTs=ts=>{const[d,t]=ts.split('-'),y=+d.slice(0,4),m=+d.slice(4,6)-1,da=+d.slice(6,8),[h,mi,s,ms]=t.split(':').map(Number);return new Date(y,m,da,h,mi,s,ms);};
const computeDurationSeconds=(a,b)=>{try{return Math.max(1,Math.round((parseTs(b)-parseTs(a))/1e3));}catch{return 1;}};
const computeSecondsDiff=(a,b)=>{try{return Math.max(0,Math.floor((parseTs(b)-parseTs(a))/1e3));}catch{return 0;}};

const detectBossPulls = (damageTimelineByTarget, firstTs) => {
  const pulls = [];
  let currentPull = null;
  const MAX_GAP_SECONDS = 30;

  Object.entries(damageTimelineByTarget || {}).forEach(([bossName, timeline]) => {
    const times = Object.keys(timeline).sort((a, b) => computeSecondsDiff(firstTs, a) - computeSecondsDiff(firstTs, b));
    
    for (let i = 0; i < times.length; i++) {
      const ts = times[i];
      const sec = computeSecondsDiff(firstTs, ts);
      
      if (!currentPull || currentPull.bossName !== bossName || (sec - currentPull.endSec) > MAX_GAP_SECONDS) {
        currentPull = { 
          bossName, 
          startSec: sec, 
          endSec: sec, 
          damage: timeline[ts] || 0,
          hits: 1 
        };
        pulls.push(currentPull);
      } else {
        currentPull.endSec = sec;
        currentPull.damage += timeline[ts] || 0;
        currentPull.hits += 1;
      }
    }
  });
  
  return pulls.sort((a, b) => a.startSec - b.startSec);
};

function parseLogFile(file,index){return new Promise(res=>{
  if(file.size>20*1024*1024)return res(null);
  const r=new FileReader();
  r.onload=()=>{try{
    const lines=r.result.split(/\r?\n/),
          damageBySkill={},
          damageTimeline={},
          damageByTarget={},
          damageBySkillTimeline={},
          damageTimelineByTarget={},
          damageBySkillTimelineByTarget={};
    let totalDamage=0,hitCount=0,maxHit=0,firstTs=null,lastTs=null,
        playerName='Unknown',bossName='Unknown';

    for(const line of lines){
      if(!line)continue;
      const parts=line.split(',');
      if(parts.length<10)continue;
      const type=(parts[1]||'').trim().toLowerCase();
      if(!type.includes('damage'))continue;

      const ts=parts[0].trim(),
            skillName=parts[2].trim(),
            dmg=parseInt(parts[4].trim().replace(/\s/g,''),10),
            player=parts[parts.length-2].trim(),
            boss=parts[parts.length-1].trim();

      if(!firstTs)firstTs=ts;
      const sec=computeSecondsDiff(firstTs,ts);

      if(!Number.isNaN(dmg)&&dmg>0){
        totalDamage+=dmg;
        hitCount++;
        if(dmg>maxHit)maxHit=dmg;

        damageBySkill[skillName]=(damageBySkill[skillName]||0)+dmg;

        if(!damageBySkillTimeline[sec])damageBySkillTimeline[sec]={};
        damageBySkillTimeline[sec][skillName]=(damageBySkillTimeline[sec][skillName]||0)+dmg;

        if(!damageBySkillTimelineByTarget[boss])damageBySkillTimelineByTarget[boss]={};
        if(!damageBySkillTimelineByTarget[boss][sec])damageBySkillTimelineByTarget[boss][sec]={};
        damageBySkillTimelineByTarget[boss][sec][skillName]=(damageBySkillTimelineByTarget[boss][sec][skillName]||0)+dmg;

        if(!damageByTarget[boss])damageByTarget[boss]={totalDamage:0,hits:0,bySkill:{}};
        const tgt=damageByTarget[boss];
        tgt.totalDamage+=dmg;
        tgt.hits++;
        tgt.bySkill[skillName]=(tgt.bySkill[skillName]||0)+dmg;

        if(!damageTimelineByTarget[boss])damageTimelineByTarget[boss]={};
        damageTimelineByTarget[boss][sec]=(damageTimelineByTarget[boss][sec]||0)+dmg;

        damageTimeline[sec]=(damageTimeline[sec]||0)+dmg;
      }

      lastTs=ts;
      playerName=player;
      bossName=boss;
    }

    if(!hitCount||!firstTs||!lastTs)return res(null);
    const lastSec=computeSecondsDiff(firstTs,lastTs);

    const bossPulls = detectBossPulls(damageTimelineByTarget, firstTs);

    const duration=computeDurationSeconds(firstTs,lastTs),
          dps=duration>0?Math.round(totalDamage/duration):totalDamage,
          avgHit=Math.round(totalDamage/hitCount),
          avgDpsTimeline={};
    let cum=0;
    for(let s=0;s<=duration;s++){
      const dmg=damageTimeline[s]||0;
      cum+=dmg;
      avgDpsTimeline[s]=cum/Math.max(1,s+1);
    }

    res({
      index,
      playerName,
      bossName,
      totalDamage,
      hitCount,
      maxHit,
      avgHit,
      duration,
      dps,
      damageBySkill,
      damageTimeline,
      avgDpsTimeline,
      damageByTarget,
      bossPulls,
      damageBySkillTimeline,
      damageTimelineByTarget,
      damageBySkillTimelineByTarget
    });
  }catch{res(null);}};
  r.onerror=()=>res(null);
  r.readAsText(file);
});}

// TOUTES LES FONCTIONS SANS wipe (reste identique au code original)
function initTimeSlider(maxD){
  if(maxD<1)maxD=1;
  if(!timeSlider){
    noUiSlider.create(timeRangeSliderEl,{
      start:[0,maxD],
      connect:true,
      step:1,
      range:{min:0,max:maxD},
      tooltips:false
    });
    timeSlider=timeRangeSliderEl;
    timeSlider.noUiSlider.on('update',v=>{
      const[from,to]=v.map(x=>Math.round(x));
      timeFilter={from,to};
      timeRangeLabel.textContent=`${from}s - ${to}s`;
      renderPlayerTable(playersData);
      highlightSelectedRows();
      renderTargetsTable();
      refreshCharts();
    });
  }else{
    timeSlider.noUiSlider.updateOptions({start:[0,maxD],range:{min:0,max:maxD}});
    timeFilter={from:0,to:maxD};
    timeRangeLabel.textContent=`0s - ${maxD}s`;
  }
}

function buildPlayerStatsInWindow(p){
  const from=timeFilter.from??0;
  const to=Math.min(timeFilter.to??p.duration,p.duration);

  const byTarget=p.damageTimelineByTarget && selectedTarget
    ? p.damageTimelineByTarget[selectedTarget]
    : null;
  const baseTimeline=byTarget || p.damageTimeline;

  let total=0,hits=0,max=0;
  for(let s=from;s<=to;s++){
    const dmg=baseTimeline[s]||0;
    if(dmg>0){total+=dmg;hits++;if(dmg>max)max=dmg;}
  }
  const duration=Math.max(1,to-from+1);
  const dps=Math.round(total/duration);
  const avgHit=hits?Math.round(total/hits):0;
  return{totalDamage:total,hitCount:hits,maxHit:max,duration,dps,avgHit};
}

function buildAvgDpsTimelineWindow(p,from,to){
  const byTarget=p.damageTimelineByTarget && selectedTarget
         ? p.damageTimelineByTarget[selectedTarget]
      : null;
  const baseTimeline=byTarget || p.damageTimeline;

  let cum=0,avg={};
  for(let s=0;s<=p.duration;s++){
    const dmg=baseTimeline[s]||0;
    cum+=dmg;
    if(s>=from&&s<=to)avg[s]=cum/Math.max(1,s+1);
  }
  return avg;
}

function buildDamageBySkillInWindow(p){
  const from=timeFilter.from??0,to=Math.min(timeFilter.to??p.duration,p.duration),tot={};
  for(let s=from;s<=to;s++){
    const skills=p.damageBySkillTimeline?.[s];
    if(!skills)continue;
    Object.entries(skills).forEach(([sk,d])=>{tot[sk]=(tot[sk]||0)+d;});
  }
  return tot;
}

function buildDamageBySkillForTargetInWindow(p,target){
  const base=p.damageBySkillTimelineByTarget && p.damageBySkillTimelineByTarget[target];
  if(!base)return buildDamageBySkillInWindow(p);
  const from=timeFilter.from??0,to=Math.min(timeFilter.to??p.duration,p.duration),tot={};
  for(let s=from;s<=to;s++){
    const skills=base[s];
    if(!skills)continue;
    Object.entries(skills).forEach(([sk,d])=>{
      tot[sk]=(tot[sk]||0)+d;
    });
  }
  return tot;
}

function renderPullsTable() {
  const pulls = playersData[0]?.bossPulls || [];
  pullsBody.innerHTML = '';
  
  pulls.forEach((pull, i) => {
    const duration = pull.endSec - pull.startSec + 1;
    const dps = duration > 0 ? Math.round(pull.damage / duration) : 0;
    const isKill = i === pulls.length - 1 && pull.damage > 500000;
    
    const tr = document.createElement('tr');
    tr.className = isKill ? 'kill-row' : 'wipe-row';
    tr.innerHTML = `
      <td style="font-weight:600;">${i + 1}</td>
      <td style="color:#4fd1ff;font-weight:600;">${pull.bossName}</td>
      <td>${pull.startSec}s</td>
      <td>${duration}s</td>
      <td>${pull.damage.toLocaleString('fr-FR')}</td>
      <td>${dps.toLocaleString('fr-FR')}</td>
      <td style="color:${isKill ? '#10b981' : '#ef4444'};font-weight:700;font-size:14px;">
        ${isKill ? 'âœ… KILL' : 'ðŸ’€ Wipe'}
      </td>
    `;
    pullsBody.appendChild(tr);
  });
}

function renderPlayerTable(players){
  playerBody.innerHTML='';

  const rows=players.map(p=>{
    const stats=buildPlayerStatsInWindow(p);
    return{player:p,stats};
  });

  const totalDamageAll=rows.reduce((s,r)=>s+r.stats.totalDamage,0);

  rows.forEach((row,i)=>{
    const p=row.player,s=row.stats,tr=document.createElement('tr');
    tr.dataset.index=p.index;
    const c=getColorForIndex(p.index);
    const percent=totalDamageAll>0?s.totalDamage/totalDamageAll*100:0;

    tr.innerHTML=`<td>${i+1}</td>
      <td style="color:${c.text};">${p.playerName}</td>
      <td>${s.dps.toLocaleString('fr-FR')}</td>
      <td>${s.totalDamage.toLocaleString('fr-FR')}</td>
      <td>${percent.toFixed(2)}%</td>
      <td>${s.hitCount.toLocaleString('fr-FR')}</td>
      <td>${s.avgHit?s.avgHit.toLocaleString('fr-FR'):'-'}</td>
      <td>${s.maxHit.toLocaleString('fr-FR')}</td>
      <td>${s.duration}s</td>
      <td style="width:40px;"><span class="remove-player" data-index="${p.index}" title="Retirer ce joueur des logs">âœ•</span></td>`;

    if(selectedPlayers.some(sp=>sp.index===p.index)){
      tr.classList.add('player-selected');
      tr.style.backgroundColor=c.rowBg;
    }
    playerBody.appendChild(tr);
  });

  const totalFiltered=rows.reduce((s,r)=>s+r.stats.totalDamage,0);
  const avgDpsFiltered=rows.length?rows.reduce((s,r)=>s+r.stats.dps,0)/rows.length:0;
  document.getElementById('sumTotalDamage').textContent=totalFiltered.toLocaleString('fr-FR');
  document.getElementById('sumAvgDps').textContent=Math.round(avgDpsFiltered).toLocaleString('fr-FR');
  
  const pullsInfo = playersData[0]?.bossPulls?.length 
    ? ` (${playersData[0].bossPulls.length} pulls)` : '';
  document.getElementById('sumBossName').textContent = 
    (selectedTarget || playersData[0]?.bossName || '---') + pullsInfo;
}

function highlightSelectedRows(){
  playerBody.querySelectorAll('tr').forEach(r=>{
    const idx=+r.dataset.index;
    const p=playersData.find(pl=>pl.index===idx);
    const sel=selectedPlayers.some(sp=>sp.index===idx);
    r.classList.toggle('player-selected',sel);
    r.style.backgroundColor='';
    if(sel&&p){
      const c=getColorForIndex(p.index);
      r.style.backgroundColor=c.rowBg;
    }
  });
}

function renderTargetsTable(){
  targetsBody.innerHTML='';
  const totals={};
  playersData.forEach(p=>{
    if(!p.damageByTarget)return;
    Object.entries(p.damageByTarget).forEach(([t,info])=>{
      if(!totals[t])totals[t]={totalDamage:0,hits:0};
      totals[t].totalDamage+=info.totalDamage;
      totals[t].hits+=info.hits;
    });
  });

  Object.entries(totals).sort((a,b)=>b[1].totalDamage-a[1].totalDamage).forEach(([t,info])=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${t}</td><td>${info.totalDamage.toLocaleString('fr-FR')}</td><td>${info.hits.toLocaleString('fr-FR')}</td>`;
    tr.onclick=()=>{
      selectedTarget=t;
      renderPlayerTable(playersData);
      highlightSelectedRows();
      refreshCharts();
      document.getElementById('sumBossName').textContent=t;
    };
    targetsBody.appendChild(tr);
  });
}

function drawComparisonChart(){
  const ctx=document.getElementById('damageChart').getContext('2d');
  if(skillChart)skillChart.destroy();
  const meta=document.getElementById('playersMeta');
  if(!selectedPlayers.length){meta.textContent='';return;}

  const allSkills=new Set();
  const perPlayer=selectedPlayers.map(p=>{
    const totals=selectedTarget?buildDamageBySkillForTargetInWindow(p,selectedTarget):buildDamageBySkillInWindow(p);
    Object.keys(totals).forEach(k=>allSkills.add(k));
    return{player:p,totals};
  });

  const global={};
  perPlayer.forEach(({totals})=>{
    Object.entries(totals).forEach(([sk,d])=>{global[sk]=(global[sk]||0)+d;});
  });

  const labels=Array.from(allSkills).sort((a,b)=>(global[b]||0)-(global[a]||0));
  const datasets=perPlayer.map(({player,totals})=>{
    const c=getColorForIndex(player.index);
    return{
      label:selectedTarget?`${player.playerName} (${selectedTarget})`:player.playerName,
      data:labels.map(sk=>totals[sk]||0),
      backgroundColor:c.barBg,
      borderColor:c.barBorder,
      borderWidth:1,
      borderRadius:6,
      borderSkipped:false
    };
  });

  meta.textContent=perPlayer.length===1?perPlayer[0].player.playerName:perPlayer.map(p=>p.player.playerName).join(' vs ');
  document.getElementById('chartContainer').style.height=Math.max(450,labels.length*40)+'px';

  skillChart=new Chart(ctx,{
    type:'bar',
    data:{labels,datasets},
    options:{
      indexAxis:'y',
      responsive:true,
      maintainAspectRatio:false,
      categoryPercentage:.9,
      barPercentage:.7,
      animation:false,
      plugins:{
        legend:{display:true},
        title:{display:false},
        tooltip:{callbacks:{label:ctx=>{const v=ctx.parsed.x||0;return`${ctx.dataset.label} â€“ ${ctx.label}: ${v.toLocaleString('fr-FR')} dÃ©gÃ¢ts`;}}}
      },
      scales:{
        x:{ticks:{color:'#fff',maxTicksLimit:10},grid:{color:'rgba(255,255,255,.1)'}},
        y:{ticks:{color:'#fff'},grid:{color:'rgba(255,255,255,.1)'}}
      }
    }
  });
}

function drawAvgDpsTimeline(){
  const ctx=document.getElementById('avgDpsTimeline').getContext('2d');
  if(avgDpsTimelineChart)avgDpsTimelineChart.destroy();
  const meta=document.getElementById('avgFightDurationMeta');
  if(!selectedPlayers.length){meta.textContent='';return;}

  const maxD=Math.max(...selectedPlayers.map(p=>p.duration));
  const from=timeFilter.from??0;
  const to=Math.min(timeFilter.to??maxD,maxD);
  meta.textContent=`${from}s - ${to}s (fight ${maxD}s)`;

  const labels=[];
  for(let s=from;s<=to;s++)labels.push(`${s}s`);

  const datasets=selectedPlayers.map(p=>{
    const avg=buildAvgDpsTimelineWindow(p,from,to);
    const c=getColorForIndex(p.index);
    return{
      label:selectedTarget?`${p.playerName} (${selectedTarget})`:p.playerName,
      data:labels.map((_,i)=>avg[from+i]||0),
      borderColor:c.line,
      backgroundColor:'transparent',
      pointRadius:0,
      borderWidth:1.8,
      tension:.15
    };
  });

  avgDpsTimelineChart=new Chart(ctx,{
    type:'line',
    data:{labels,datasets},
    options:{
      responsive:true,
      maintainAspectRatio:false,
      animation:false,
      plugins:{
        legend:{display:true},
        title:{display:true,text:'Average DPS Over Time (timeâ€‘windowed)'},
        tooltip:{callbacks:{label:ctx=>{const v=ctx.parsed.y||0;return`${ctx.dataset.label}: ${Math.round(v).toLocaleString('fr-FR')} DPS moyen`;}}},
        zoom:{zoom:{wheel:{enabled:true},drag:{enabled:true},mode:'x'},pan:{enabled:true,mode:'x'}}
      },
      scales:{
        x:{ticks:{color:'#fff',maxTicksLimit:15},grid:{color:'rgba(255,255,255,.08)'}},
        y:{ticks:{color:'#fff'},grid:{color:'rgba(255,255,255,.08)'}}
      }
    },
    plugins:[{id:'bossBackgrounds',beforeDraw(chart){
      const{ctx,chartArea,scales:{x}}=chart;
      if(!globalBossPhases?.length)return;
      const cols=['rgba(80,40,120,.35)','rgba(160,120,40,.35)','rgba(20,80,120,.35)','rgba(80,120,40,.35)'];
      globalBossPhases.forEach((ph,i)=>{
        const s=Math.max(ph.startSec,from),e=Math.min(ph.endSec,to);
        if(e<=s)return;
        const xs=x.getPixelForValue(s-from),xe=x.getPixelForValue(e-from);
        ctx.save();
        ctx.fillStyle=cols[i%cols.length];
        ctx.fillRect(xs,chartArea.top,xe-xs,chartArea.bottom-chartArea.top);
        ctx.fillStyle='#fff';
        ctx.font='10px Arial';
        ctx.textAlign='center';
        ctx.fillText(ph.name,(xs+xe)/2,chartArea.top+12);
        ctx.restore();
      });
    }}]
  });
}

function drawDpsTimeline(){
  const ctx=document.getElementById('dpsTimeline').getContext('2d');
  if(dpsTimelineChart)dpsTimelineChart.destroy();
  const meta=document.getElementById('fightDurationMeta');
  if(!selectedPlayers.length){meta.textContent='';return;}

  const maxD=Math.max(...selectedPlayers.map(p=>p.duration));
  const from=timeFilter.from??0;
  const to=Math.min(timeFilter.to??maxD,maxD);
  meta.textContent=`${from}s - ${to}s (fight ${maxD}s)`;

  const labels=[];
  for(let s=from;s<=to;s++)labels.push(`${s}s`);

  const datasets=selectedPlayers.map(p=>{
    const byTarget=p.damageTimelineByTarget && selectedTarget
      ? p.damageTimelineByTarget[selectedTarget]
      : null;
    const baseTimeline=byTarget || p.damageTimeline;

    const c=getColorForIndex(p.index);
    return{
      label:selectedTarget?`${p.playerName} (${selectedTarget})`:p.playerName,
      data:labels.map((_,i)=>baseTimeline[from+i]||0),
      borderColor:c.line,
      backgroundColor:'transparent',
      pointRadius:0,
      borderWidth:1.5,
      tension:.2
    };
  });

  dpsTimelineChart=new Chart(ctx,{
    type:'line',
    data:{labels,datasets},
    options:{
      responsive:true,
      maintainAspectRatio:false,
      animation:false,
      plugins:{
        legend:{display:true},
        title:{display:false},
        tooltip:{callbacks:{label:ctx=>{const v=ctx.parsed.y||0;return`${ctx.dataset.label}: ${v.toLocaleString('fr-FR')} DPS`;}}}
      },
      scales:{
        x:{ticks:{color:'#fff',maxTicksLimit:15},grid:{color:'rgba(255,255,255,.08)'}},
        y:{ticks:{color:'#fff'},grid:{color:'rgba(255,255,255,.08)'}}
      }
    }
  });
}

function refreshCharts(){
  if(skillChart){skillChart.destroy();skillChart=null;}
  if(dpsTimelineChart){dpsTimelineChart.destroy();dpsTimelineChart=null;}
  if(avgDpsTimelineChart){avgDpsTimelineChart.destroy();avgDpsTimelineChart=null;}
  drawComparisonChart();
  drawAvgDpsTimeline();
  drawDpsTimeline();
}

toggleTargetsBtn.onclick=()=>{
  const hidden=getComputedStyle(targetsWrapper).display==='none';
  if(hidden){
    renderTargetsTable();
    targetsWrapper.style.display='block';
    toggleTargetsBtn.textContent='Hide other targets';
  }else{
    targetsWrapper.style.display='none';
    toggleTargetsBtn.textContent='Show other targets';
  }
};

togglePullsBtn.onclick=()=>{
  const hidden=getComputedStyle(pullsWrapper).display==='none';
  if(hidden){
    renderPullsTable();
    pullsWrapper.style.display='block';
    togglePullsBtn.textContent='Hide Boss Pulls';
  }else{
    pullsWrapper.style.display='none';
    togglePullsBtn.textContent='Show Boss Pulls';
  }
};

resetAvgZoomBtn.onclick=()=>{if(avgDpsTimelineChart)avgDpsTimelineChart.resetZoom();};

playerBody.onclick=e=>{
  const rm=e.target.closest('.remove-player');
  if(rm){
    const idx=+rm.dataset.index;
    playersData=playersData.filter(p=>p.index!==idx);
    selectedPlayers=selectedPlayers.filter(p=>p.index!==idx);
    playersData.forEach((p,i)=>p.index=i);

    renderPlayerTable(playersData);
    highlightSelectedRows();
    refreshCharts();

    document.getElementById('sumPlayers').textContent=playersData.length;
    return;
  }

  const row=e.target.closest('tr');
  if(!row)return;
  const idx=+row.dataset.index;
  const p=playersData.find(pl=>pl.index===idx);
  if(!p)return;

  const exists=selectedPlayers.some(pl=>pl.index===p.index);
  selectedPlayers=exists
    ? selectedPlayers.filter(pl=>pl.index!==p.index)
    : [...selectedPlayers,p];

  renderPlayerTable(playersData);
  highlightSelectedRows();
  refreshCharts();
};

clearLogsBtn.onclick=()=>{
  playersData=[];
  selectedPlayers=[];
  selectedTarget=null;
  timeFilter={from:0,to:null};
  if(timeSlider){
    timeSlider.noUiSlider.updateOptions({start:[0,0],range:{min:0,max:0}});
    timeRangeLabel.textContent='0s - 0s';
  }
  playerBody.innerHTML='';
  targetsBody.innerHTML='';
  pullsBody.innerHTML='';
  targetsWrapper.style.display='none';
  pullsWrapper.style.display='none';
  toggleTargetsBtn.textContent='Show other targets';
  togglePullsBtn.textContent='Show Boss Pulls';
  document.getElementById('sumTotalDamage').textContent='0';
  document.getElementById('sumAvgDps').textContent='0';
  document.getElementById('sumPlayers').textContent='0';
  document.getElementById('sumBossName').textContent='---';
  statusEl.textContent='Logs cleared.';
  if(skillChart){skillChart.destroy();skillChart=null;}
  if(dpsTimelineChart){dpsTimelineChart.destroy();dpsTimelineChart=null;}
  if(avgDpsTimelineChart){avgDpsTimelineChart.destroy();avgDpsTimelineChart=null;}
};

function handleFiles(){
  let files=[...fileInput.files];
  if(!files.length)return;
  files=files.filter(f=>f.size<20*1024*1024);
  if(!files.length){statusEl.textContent='Files are too large.';return;}
  statusEl.textContent='Reading log files...';
  selectedTarget=null;
  targetsBody.innerHTML='';
  targetsWrapper.style.display='none';
  toggleTargetsBtn.textContent='Show other targets';
  if(skillChart)skillChart.destroy();
  if(dpsTimelineChart)dpsTimelineChart.destroy();
  if(avgDpsTimelineChart)avgDpsTimelineChart.destroy();

  const baseIndex=playersData.length;
  Promise.all(files.map((f,i)=>parseLogFile(f,baseIndex+i))).then(res=>{
    const newP=res.filter(Boolean);
    if(!newP.length){statusEl.textContent='No valid data found in the added logs.';return;}
    playersData=playersData.concat(newP);
    playersData.sort((a,b)=>b.dps-a.dps);
    playersData.forEach((p,i)=>p.index=i);

    const boss=playersData[0].bossName&&playersData[0].bossName!=='Unknown'
      ? playersData[0].bossName:'Unknown target';
    
    const pullsCount = playersData[0]?.bossPulls?.length || 0;
    if (pullsCount > 1) {
      pullsWrapper.style.display = 'block';
      togglePullsBtn.textContent = 'Hide Boss Pulls';
      renderPullsTable();
      statusEl.textContent = `Logs loaded: ${playersData.length} players, ${pullsCount} pulls detected!`;
    } else {
      statusEl.textContent = `Logs loaded: ${playersData.length}`;
    }

    const total=playersData.reduce((s,p)=>s+p.totalDamage,0),
          avg=playersData.reduce((s,p)=>s+p.dps,0)/playersData.length;
    document.getElementById('sumTotalDamage').textContent=total.toLocaleString('fr-FR');
    document.getElementById('sumAvgDps').textContent=Math.round(avg).toLocaleString('fr-FR');
    document.getElementById('sumPlayers').textContent=playersData.length;
    document.getElementById('sumBossName').textContent=boss;

    renderPlayerTable(playersData);
    if(playersData.length>0)selectedPlayers=[playersData[0]];
    highlightSelectedRows();

    const maxD=Math.max(...playersData.map(p=>p.duration));
    initTimeSlider(maxD);
    refreshCharts();
  }).catch(err=>{
    statusEl.textContent='Error: '+err;
  });
}

fileInput.addEventListener('change',handleFiles);
</script>
</body>
</html>

