<script>
  const fileInput = document.getElementById('logFile');
  const dropZone  = document.getElementById('dropZone');
  const statusEl  = document.getElementById('status');
  const playerBody = document.getElementById('playerBody');
  const targetsTable = document.getElementById('targetsTable');
  const targetsBody  = document.getElementById('targetsBody');
  const toggleTargetsBtn = document.getElementById('toggleTargetsBtn');
  const resetAvgZoomBtn = document.getElementById('resetAvgZoomBtn');
  const logPathEl = document.getElementById('logPath');
  const copyMsgEl = document.getElementById('copyMsg');
  const clearLogsBtn = document.getElementById('clearLogsBtn');
  const timeRangeLabel = document.getElementById('timeRangeLabel');
  const timeRangeSliderEl = document.getElementById('timeRangeSlider');

  let skillChart;
  let dpsTimelineChart;
  let avgDpsTimelineChart;
  let playersData = [];
  let selectedPlayers = [];
  let selectedTarget = null;
  let globalBossPhases = [];
  let timeSlider = null;
  let timeFilter = { from: 0, to: null };

  const BAR_COLORS = [
    'rgba(88, 101, 242, 0.8)',
    'rgba(46, 204, 113, 0.8)',
    'rgba(231, 76, 60, 0.8)',
    'rgba(241, 196, 15, 0.8)',
    'rgba(155, 89, 182, 0.8)',
    'rgba(26, 188, 156, 0.8)',
    'rgba(230, 126, 34, 0.8)',
    'rgba(149, 165, 166, 0.8)'
  ];
  const BAR_BORDER_COLORS = [
    'rgba(88, 101, 242, 1)',
    'rgba(46, 204, 113, 1)',
    'rgba(231, 76, 60, 1)',
    'rgba(241, 196, 15, 1)',
    'rgba(155, 89, 182, 1)',
    'rgba(26, 188, 156, 1)',
    'rgba(230, 126, 34, 1)',
    'rgba(149, 165, 166, 1)'
  ];
  const LINE_COLORS = [
    'rgba(255, 99, 132, 1)',
    'rgba(54, 162, 235, 1)',
    'rgba(75, 192, 192, 1)',
    'rgba(255, 206, 86, 1)',
    'rgba(153, 102, 255, 1)',
    'rgba(255, 159, 64, 1)',
    'rgba(46, 204, 113, 1)',
    'rgba(231, 76, 60, 1)',
    'rgba(52, 152, 219, 1)',
    'rgba(241, 196, 15, 1)'
  ];

  function getColorForIndex(idx) {
    return {
      rowBg: BAR_COLORS[idx % BAR_COLORS.length],
      text: '#ffffff',
      barBg: BAR_COLORS[idx % BAR_COLORS.length],
      barBorder: BAR_BORDER_COLORS[idx % BAR_BORDER_COLORS.length],
      line: LINE_COLORS[idx % LINE_COLORS.length]
    };
  }

  logPathEl.addEventListener('click', () => {
    navigator.clipboard.writeText('%LOCALAPPDATA%\\TL\\SAVED\\COMBATLOGS')
      .then(() => {
        copyMsgEl.textContent = 'Path copied ✔';
        setTimeout(() => { copyMsgEl.textContent = ''; }, 2000);
      });
  });

  dropZone.addEventListener('click', () => fileInput.click());
  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.style.borderColor = '#4fd1ff';
    dropZone.style.background  = '#15172a';
  });
  dropZone.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dropZone.style.borderColor = '#5865F2';
    dropZone.style.background  = '#10111b';
  });
  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.style.borderColor = '#5865F2';
    dropZone.style.background  = '#10111b';
    const files = e.dataTransfer.files;
    if (!files.length) return;
    fileInput.files = files;
    handleFiles();
  });

  function parseTs(ts) {
    const [datePart, timePart] = ts.split('-');
    const year = +datePart.slice(0, 4);
    const month = +datePart.slice(4, 6) - 1;
    const day = +datePart.slice(6, 8);
    const [h, m, s, ms] = timePart.split(':').map(n => +n);
    return new Date(year, month, day, h, m, s, ms);
  }
  function computeDurationSeconds(ts1, ts2) {
    try {
      return Math.max(1, Math.round((parseTs(ts2) - parseTs(ts1)) / 1000));
    } catch {
      return 1;
    }
  }
  function computeSecondsDiff(tsStart, tsCurrent) {
    try {
      return Math.max(0, Math.floor((parseTs(tsCurrent) - parseTs(tsStart)) / 1000));
    } catch {
      return 0;
    }
  }

  function parseLogFile(file, index) {
    return new Promise(resolve => {
      if (file.size > 20 * 1024 * 1024) {
        resolve(null);
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const lines = reader.result.split(/\r?\n/);

          const damageBySkill = {};
          const damageTimeline = {};
          const damageByTarget = {};
          const damageBySkillTimeline = {};
          const bossPhases = [];

          let totalDamage = 0;
          let hitCount = 0;
          let maxHit = 0;
          let firstTs = null;
          let lastTs = null;
          let playerName = 'Unknown';
          let bossName = 'Unknown';
          let currentBoss = null;
          let currentBossStartSec = 0;

          for (const line of lines) {
            if (!line) continue;
            const parts = line.split(',');
            if (parts.length < 10) continue;

            const type = (parts[1] || '').trim().toLowerCase();
            if (!type.includes('damage')) continue;

            const ts = parts[0].trim();
            const skillName = parts[2].trim();
            const dmg = parseInt(parts[4].trim().replace(/\s/g, ''), 10);
            const player = parts[parts.length - 2].trim();
            const boss = parts[parts.length - 1].trim();

            if (!firstTs) firstTs = ts;
            const secFromStart = computeSecondsDiff(firstTs, ts);

            if (boss !== currentBoss) {
              if (currentBoss !== null) {
                bossPhases.push({
                  name: currentBoss,
                  startSec: currentBossStartSec,
                  endSec: secFromStart
                });
              }
              currentBoss = boss;
              currentBossStartSec = secFromStart;
            }

            if (!Number.isNaN(dmg) && dmg > 0) {
              totalDamage += dmg;
              hitCount++;
              if (dmg > maxHit) maxHit = dmg;

              damageBySkill[skillName] = (damageBySkill[skillName] || 0) + dmg;

              if (!damageBySkillTimeline[secFromStart]) {
                damageBySkillTimeline[secFromStart] = {};
              }
              damageBySkillTimeline[secFromStart][skillName] =
                (damageBySkillTimeline[secFromStart][skillName] || 0) + dmg;

              if (!damageByTarget[boss]) {
                damageByTarget[boss] = { totalDamage: 0, hits: 0, bySkill: {} };
              }
              const tgt = damageByTarget[boss];
              tgt.totalDamage += dmg;
              tgt.hits++;
              tgt.bySkill[skillName] = (tgt.bySkill[skillName] || 0) + dmg;

              damageTimeline[secFromStart] = (damageTimeline[secFromStart] || 0) + dmg;
            }

            lastTs = ts;
            playerName = player;
            bossName = boss;
          }

          if (!hitCount || !firstTs || !lastTs) {
            resolve(null);
            return;
          }

          const lastSec = computeSecondsDiff(firstTs, lastTs);
          if (currentBoss !== null) {
            bossPhases.push({
              name: currentBoss,
              startSec: currentBossStartSec,
              endSec: lastSec
            });
          }

          const duration = computeDurationSeconds(firstTs, lastTs);
          const dps = duration > 0 ? Math.round(totalDamage / duration) : totalDamage;
          const avgHit = Math.round(totalDamage / hitCount);

          const avgDpsTimeline = {};
          let cumulative = 0;
          for (let s = 0; s <= duration; s++) {
            const dmg = damageTimeline[s] || 0;
            cumulative += dmg;
            avgDpsTimeline[s] = cumulative / Math.max(1, s + 1);
          }

          resolve({
            index,
            playerName,
            bossName,
            totalDamage,
            hitCount,
            maxHit,
            avgHit,
            duration,
            dps,
            damageBySkill,
            damageTimeline,
            avgDpsTimeline,
            damageByTarget,
            bossPhases,
            damageBySkillTimeline
          });
        } catch {
          resolve(null);
        }
      };
      reader.onerror = () => resolve(null);
      reader.readAsText(file);
    });
  }

  function initTimeSlider(maxDuration) {
    if (maxDuration < 1) maxDuration = 1;

    if (!timeSlider) {
      noUiSlider.create(timeRangeSliderEl, {
        start: [0, maxDuration],
        connect: true,
        step: 1,
        range: { min: 0, max: maxDuration },
        tooltips: false
      });
      timeSlider = timeRangeSliderEl;

      timeSlider.noUiSlider.on('update', (values) => {
        const from = Math.round(values[0]);
        const to   = Math.round(values[1]);
        timeFilter.from = from;
        timeFilter.to   = to;
        timeRangeLabel.textContent = from + 's - ' + to + 's';

        renderPlayerTable(playersData);
        highlightSelectedRows();
        renderTargetsTable();
        refreshCharts();
      });
    } else {
      timeSlider.noUiSlider.updateOptions({
        start: [0, maxDuration],
        range: { min: 0, max: maxDuration }
      });
      timeFilter.from = 0;
      timeFilter.to   = maxDuration;
      timeRangeLabel.textContent = '0s - ' + maxDuration + 's';
    }
  }

  function applyTimeWindowToTimeline(timeline, duration) {
    const from = timeFilter.from ?? 0;
    const to   = timeFilter.to   ?? duration;
    const filtered = {};
    for (let s = 0; s <= duration; s++) {
      if (s < from || s > to) continue;
      if (timeline[s]) filtered[s] = timeline[s];
    }
    return { filtered, from, to };
  }

  function buildPlayerStatsInWindow(player) {
    const from = timeFilter.from ?? 0;
    const to   = Math.min(timeFilter.to ?? player.duration, player.duration);

    let totalDamage = 0;
    let hitCount = 0;
    let maxHit = 0;

    for (let s = from; s <= to; s++) {
      const dmg = player.damageTimeline[s] || 0;
      if (dmg > 0) {
        totalDamage += dmg;
        hitCount++;
        if (dmg > maxHit) maxHit = dmg;
      }
    }

    const duration = Math.max(1, to - from + 1);
    const dps = Math.round(totalDamage / duration);
    const avgHit = hitCount > 0 ? Math.round(totalDamage / hitCount) : 0;

    return { totalDamage, hitCount, maxHit, duration, dps, avgHit };
  }

  function buildAvgDpsTimelineWindow(player, from, to) {
    let cumulative = 0;
    const avg = {};
    for (let s = 0; s <= player.duration; s++) {
      const dmg = player.damageTimeline[s] || 0;
      cumulative += dmg;
      if (s >= from && s <= to) {
        avg[s] = cumulative / Math.max(1, s + 1);
      }
    }
    return avg;
  }

  function buildDamageBySkillInWindow(player) {
    const from = timeFilter.from ?? 0;
    const to   = Math.min(timeFilter.to ?? player.duration, player.duration);
    const skillTotals = {};

    for (let s = from; s <= to; s++) {
      const skillsAtSec = player.damageBySkillTimeline?.[s];
      if (!skillsAtSec) continue;
      Object.entries(skillsAtSec).forEach(([skill, dmg]) => {
        skillTotals[skill] = (skillTotals[skill] || 0) + dmg;
      });
    }

    return skillTotals;
  }

  function buildDamageBySkillForTargetInWindow(player, targetName) {
    const targetInfo = player.damageByTarget && player.damageByTarget[targetName];
    if (!targetInfo) {
      return buildDamageBySkillInWindow(player);
    }

    const from = timeFilter.from ?? 0;
    const to   = Math.min(timeFilter.to ?? player.duration, player.duration);
    const skillTotals = {};
    const validSkills = targetInfo.bySkill || {};

    for (let s = from; s <= to; s++) {
      const skillsAtSec = player.damageBySkillTimeline?.[s];
      if (!skillsAtSec) continue;
      Object.entries(skillsAtSec).forEach(([skill, dmg]) => {
        if (!validSkills[skill]) return;
        skillTotals[skill] = (skillTotals[skill] || 0) + dmg;
      });
    }

    return skillTotals;
  }

  function renderPlayerTable(players) {
    playerBody.innerHTML = '';

    const windowStats = players.map(p => ({
      player: p,
      stats: buildPlayerStatsInWindow(p)
    }));

    const totalFightDamage = windowStats.reduce((sum, w) => sum + w.stats.totalDamage, 0);

    windowStats.forEach((w, idx) => {
      const p = w.player;
      const s = w.stats;
      const tr = document.createElement('tr');
      tr.dataset.index = p.index;

      const c = getColorForIndex(p.index);
      const percent = totalFightDamage > 0 ? (s.totalDamage / totalFightDamage) * 100 : 0;

      tr.innerHTML = `
        <td>${idx + 1}</td>
        <td style="color:${c.text};">${p.playerName}</td>
        <td>${s.dps.toLocaleString('fr-FR')}</td>
        <td>${s.totalDamage.toLocaleString('fr-FR')}</td>
        <td>${percent.toFixed(2)}%</td>
        <td>${s.hitCount.toLocaleString('fr-FR')}</td>
        <td>${s.avgHit ? s.avgHit.toLocaleString('fr-FR') : '-'}</td>
        <td>${s.maxHit.toLocaleString('fr-FR')}</td>
        <td>${s.duration}s</td>
        <td style="width:40px;">
          <span class="remove-player" data-index="${p.index}" title="Retirer ce joueur des logs">✕</span>
        </td>
      `;

      if (selectedPlayers.some(sp => sp.index === p.index)) {
        tr.classList.add('player-selected');
        tr.style.backgroundColor = c.rowBg;
      }

      playerBody.appendChild(tr);
    });

    const sumTotalDamage = windowStats.reduce((sum, w) => sum + w.stats.totalDamage, 0);
    const avgDps = windowStats.length
      ? windowStats.reduce((sum, w) => sum + w.stats.dps, 0) / windowStats.length
      : 0;
    document.getElementById('sumTotalDamage').textContent =
      sumTotalDamage.toLocaleString('fr-FR');
    document.getElementById('sumAvgDps').textContent =
      Math.round(avgDps).toLocaleString('fr-FR');
  }

  function highlightSelectedRows() {
    const rows = playerBody.querySelectorAll('tr');
    rows.forEach(row => {
      const idx = +row.dataset.index;
      const p = playersData.find(pl => pl.index === idx);
      const isSelected = selectedPlayers.some(sp => sp.index === idx);

      row.classList.toggle('player-selected', isSelected);
      row.style.backgroundColor = '';
      if (isSelected && p) {
        const c = getColorForIndex(p.index);
        row.style.backgroundColor = c.rowBg;
      }
    });
  }

  function renderTargetsTable() {
    targetsBody.innerHTML = '';
    const targetTotals = {};

    playersData.forEach(p => {
      if (!p.damageByTarget) return;
      Object.entries(p.damageByTarget).forEach(([target, info]) => {
        if (!targetTotals[target]) {
          targetTotals[target] = { totalDamage: 0, hits: 0 };
        }
        targetTotals[target].totalDamage += info.totalDamage;
        targetTotals[target].hits += info.hits;
      });
    });

    Object.entries(targetTotals)
      .sort((a, b) => b[1].totalDamage - a[1].totalDamage)
      .forEach(([target, info]) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${target}</td>
          <td>${info.totalDamage.toLocaleString('fr-FR')}</td>
          <td>${info.hits.toLocaleString('fr-FR')}</td>
        `;
        tr.addEventListener('click', () => {
          selectedTarget = target;
          refreshCharts();
        });
        targetsBody.appendChild(tr);
      });
  }

  function drawComparisonChart() {
    const ctx = document.getElementById('damageChart').getContext('2d');
    if (skillChart) skillChart.destroy();
    const playersMeta = document.getElementById('playersMeta');

    if (!selectedPlayers.length) {
      playersMeta.textContent = '';
      return;
    }

    const allSkills = new Set();

    const perPlayerSkillTotals = selectedPlayers.map(p => {
      const totals = selectedTarget
        ? buildDamageBySkillForTargetInWindow(p, selectedTarget)
        : buildDamageBySkillInWindow(p);

      Object.keys(totals).forEach(k => allSkills.add(k));
      return { player: p, totals };
    });

    const globalSkillTotals = {};
    perPlayerSkillTotals.forEach(({ totals }) => {
      Object.entries(totals).forEach(([skill, dmg]) => {
        globalSkillTotals[skill] = (globalSkillTotals[skill] || 0) + dmg;
      });
    });

    const labels = Array.from(allSkills).sort((a, b) => {
      return (globalSkillTotals[b] || 0) - (globalSkillTotals[a] || 0);
    });

    const datasets = perPlayerSkillTotals.map(({ player, totals }) => {
      const c = getColorForIndex(player.index);
      return {
        label: selectedTarget ? `${player.playerName} (${selectedTarget})` : player.playerName,
        data: labels.map(skill => totals[skill] || 0),
        backgroundColor: c.barBg,
        borderColor: c.barBorder,
        borderWidth: 1,
        borderRadius: 6,
        borderSkipped: false
      };
    });

    playersMeta.textContent =
      perPlayerSkillTotals.length === 1
        ? perPlayerSkillTotals[0].player.playerName
        : perPlayerSkillTotals.map(p => p.player.playerName).join(' vs ');

    const newHeight = Math.max(450, labels.length * 40);
    document.getElementById('chartContainer').style.height = newHeight + 'px';

    skillChart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets },
      options: {
        indexAxis: 'y',
        responsive: true,
        maintainAspectRatio: false,
        categoryPercentage: 0.9,
        barPercentage: 0.7,
        animation: false,
        plugins: {
          legend: { display: true },
          title: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed.x || 0;
                return `${ctx.dataset.label} – ${ctx.label}: ${v.toLocaleString('fr-FR')} dégâts`;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: { color: '#ffffff', maxTicksLimit: 10 },
            grid: { color: 'rgba(255,255,255,0.1)' }
          },
          y: {
            ticks: { color: '#ffffff' },
            grid: { color: 'rgba(255,255,255,0.1)' }
          }
        }
      }
    });
  }

  function drawAvgDpsTimeline() {
    const ctx = document.getElementById('avgDpsTimeline').getContext('2d');
    if (avgDpsTimelineChart) avgDpsTimelineChart.destroy();
    const fightMeta = document.getElementById('avgFightDurationMeta');
    if (!selectedPlayers.length) {
      fightMeta.textContent = '';
      return;
    }

    const maxDuration = Math.max(...selectedPlayers.map(p => p.duration));
    const from = timeFilter.from ?? 0;
    const to   = Math.min(timeFilter.to ?? maxDuration, maxDuration);
    fightMeta.textContent = `${from}s - ${to}s (fight ${maxDuration}s)`;

    const labels = [];
    for (let s = from; s <= to; s++) labels.push(`${s}s`);

    const datasets = selectedPlayers.map((p) => {
      const avgWindow = buildAvgDpsTimelineWindow(p, from, to);
      const c = getColorForIndex(p.index);
      return {
        label: p.playerName,
        data: labels.map((_, i) => {
          const sec = from + i;
          return avgWindow[sec] || 0;
        }),
        borderColor: c.line,
        backgroundColor: 'transparent',
        pointRadius: 0,
        borderWidth: 1.8,
        tension: 0.15
      };
    });

    avgDpsTimelineChart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: {
          legend: { display: true },
          title: {
            display: true,
            text: 'Average DPS Over Time (time‑windowed)'
          },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed.y || 0;
                return `${ctx.dataset.label}: ${Math.round(v).toLocaleString('fr-FR')} DPS moyen`;
              }
            }
          },
          zoom: {
            zoom: {
              wheel: { enabled: true },
              drag: { enabled: true },
              mode: 'x'
            },
            pan: { enabled: true, mode: 'x' }
          }
        },
        scales: {
          x: {
            ticks: { color: '#ffffff', maxTicksLimit: 15 },
            grid: { color: 'rgba(255,255,255,0.08)' }
          },
          y: {
            ticks: { color: '#ffffff' },
            grid: { color: 'rgba(255,255,255,0.08)' }
          }
        }
      },
      plugins: [{
        id: 'bossBackgrounds',
        beforeDraw(chart) {
          const { ctx, chartArea, scales: { x } } = chart;
          if (!globalBossPhases?.length) return;
          const colors = [
            'rgba(80, 40, 120, 0.35)',
            'rgba(160, 120, 40, 0.35)',
            'rgba(20, 80, 120, 0.35)',
            'rgba(80, 120, 40, 0.35)'
          ];
          globalBossPhases.forEach((phase, idx) => {
            const start = Math.max(phase.startSec, from);
            const end   = Math.min(phase.endSec, to);
            if (end <= start) return;
            const xStart = x.getPixelForValue(start - from);
            const xEnd   = x.getPixelForValue(end - from);
            ctx.save();
            ctx.fillStyle = colors[idx % colors.length];
            ctx.fillRect(
              xStart,
              chartArea.top,
              xEnd - xStart,
              chartArea.bottom - chartArea.top
            );
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(phase.name, (xStart + xEnd) / 2, chartArea.top + 12);
            ctx.restore();
          });
        }
      }]
    });
  }

  function drawDpsTimeline() {
    const ctx = document.getElementById('dpsTimeline').getContext('2d');
    if (dpsTimelineChart) dpsTimelineChart.destroy();
    const fightMeta = document.getElementById('fightDurationMeta');
    if (!selectedPlayers.length) {
      fightMeta.textContent = '';
      return;
    }

    const maxDuration = Math.max(...selectedPlayers.map(p => p.duration));
    const from = timeFilter.from ?? 0;
    const to   = Math.min(timeFilter.to ?? maxDuration, maxDuration);
    fightMeta.textContent = `${from}s - ${to}s (fight ${maxDuration}s)`;

    const labels = [];
    for (let s = from; s <= to; s++) labels.push(`${s}s`);

    const datasets = selectedPlayers.map((p) => {
      const { filtered } = applyTimeWindowToTimeline(p.damageTimeline, p.duration);
      const c = getColorForIndex(p.index);
      return {
        label: p.playerName,
        data: labels.map((_, i) => {
          const sec = from + i;
          return filtered[sec] || 0;
        }),
        borderColor: c.line,
        backgroundColor: 'transparent',
        pointRadius: 0,
        borderWidth: 1.5,
        tension: 0.2
      };
    });

    dpsTimelineChart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        plugins: {
          legend: { display: true },
          title: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed.y || 0;
                return `${ctx.dataset.label}: ${v.toLocaleString('fr-FR')} DPS`;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: { color: '#ffffff', maxTicksLimit: 15 },
            grid: { color: 'rgba(255,255,255,0.08)' }
          },
          y: {
            ticks: { color: '#ffffff' },
            grid: { color: 'rgba(255,255,255,0.08)' }
          }
        }
      }
    });
  }

  function refreshCharts() {
    drawComparisonChart();
    drawAvgDpsTimeline();
    drawDpsTimeline();
  }

  toggleTargetsBtn.addEventListener('click', () => {
    const isHidden = getComputedStyle(targetsTable).display === 'none';
    if (isHidden) {
      renderTargetsTable();
      targetsTable.style.display = 'table';
      toggleTargetsBtn.textContent = 'Hide other targets';
    } else {
      targetsTable.style.display = 'none';
      toggleTargetsBtn.textContent = 'Show other targets';
    }
  });

  resetAvgZoomBtn.addEventListener('click', () => {
    if (avgDpsTimelineChart) avgDpsTimelineChart.resetZoom();
  });

  playerBody.addEventListener('click', (e) => {
    const removeBtn = e.target.closest('.remove-player');
    if (removeBtn) {
      const index = +removeBtn.dataset.index;

      playersData = playersData.filter(p => p.index !== index);
      selectedPlayers = selectedPlayers.filter(p => p.index !== index);

      playersData.forEach((p, i) => { p.index = i; });
      renderPlayerTable(playersData);
      highlightSelectedRows();

      const totalFightDamage = playersData.reduce((s, p) => s + p.totalDamage, 0);
      const avgDps = playersData.length
        ? playersData.reduce((s, p) => s + p.dps, 0) / playersData.length
        : 0;
      document.getElementById('sumTotalDamage').textContent =
        totalFightDamage.toLocaleString('fr-FR');
      document.getElementById('sumAvgDps').textContent =
        Math.round(avgDps).toLocaleString('fr-FR');
      document.getElementById('sumPlayers').textContent = playersData.length;

      refreshCharts();
      return;
    }

    const row = e.target.closest('tr');
    if (!row) return;
    const index = +row.dataset.index;
    const player = playersData.find(p => p.index === index);
    if (!player) return;

    const exists = selectedPlayers.some(p => p.index === player.index);
    selectedPlayers = exists
      ? selectedPlayers.filter(p => p.index !== player.index)
      : [...selectedPlayers, player];

    renderPlayerTable(playersData);
    highlightSelectedRows();
    refreshCharts();
  });

  clearLogsBtn.addEventListener('click', () => {
    playersData = [];
    selectedPlayers = [];
    selectedTarget = null;
    globalBossPhases = [];
    timeFilter = { from: 0, to: null };
    if (timeSlider) {
      timeSlider.noUiSlider.updateOptions({
        start: [0, 0],
        range: { min: 0, max: 0 }
      });
      timeRangeLabel.textContent = '0s - 0s';
    }

    playerBody.innerHTML = '';
    targetsBody.innerHTML = '';
    targetsTable.style.display = 'none';
    toggleTargetsBtn.textContent = 'Show other targets';

    document.getElementById('sumTotalDamage').textContent = '0';
    document.getElementById('sumAvgDps').textContent = '0';
    document.getElementById('sumPlayers').textContent = '0';
    document.getElementById('sumBossName').textContent = '---';
    statusEl.textContent = 'Logs cleared.';

    if (skillChart) { skillChart.destroy(); skillChart = null; }
    if (dpsTimelineChart) { dpsTimelineChart.destroy(); dpsTimelineChart = null; }
    if (avgDpsTimelineChart) { avgDpsTimelineChart.destroy(); avgDpsTimelineChart = null; }
  });

  function handleFiles() {
    let files = Array.from(fileInput.files);
    if (!files.length) return;

    files = files.filter(f => f.size < 20 * 1024 * 1024);
    if (!files.length) {
      statusEl.textContent = 'Files are too large.';
      return;
    }

    statusEl.textContent = 'Reading log files...';

    selectedTarget = null;
    targetsBody.innerHTML = '';
    targetsTable.style.display = 'none';
    toggleTargetsBtn.textContent = 'Show other targets';

    if (skillChart) skillChart.destroy();
    if (dpsTimelineChart) dpsTimelineChart.destroy();
    if (avgDpsTimelineChart) avgDpsTimelineChart.destroy();

    const baseIndex = playersData.length;

    Promise.all(files.map((f, idx) => parseLogFile(f, baseIndex + idx)))
      .then(results => {
        const newPlayers = results.filter(Boolean);
        if (!newPlayers.length) {
          statusEl.textContent = 'No valid data found in the added logs.';
          return;
        }

        playersData = playersData.concat(newPlayers);

        playersData.sort((a, b) => b.dps - a.dps);
        playersData.forEach((p, i) => { p.index = i; });

        const bossName =
          playersData[0].bossName && playersData[0].bossName !== 'Unknown'
            ? playersData[0].bossName
            : 'Unknown target';
        document.getElementById('sumBossName').textContent = bossName;

        const totalFightDamage = playersData.reduce((s, p) => s + p.totalDamage, 0);
        const avgDps = playersData.reduce((s, p) => s + p.dps, 0) / playersData.length;
        document.getElementById('sumTotalDamage').textContent =
          totalFightDamage.toLocaleString('fr-FR');
        document.getElementById('sumAvgDps').textContent =
          Math.round(avgDps).toLocaleString('fr-FR');
        document.getElementById('sumPlayers').textContent = playersData.length;

        renderPlayerTable(playersData);
        statusEl.textContent = `Logs loaded: ${playersData.length}`;

        if (playersData.length > 0) {
          selectedPlayers = [playersData[0]];
        }

        highlightSelectedRows();
        globalBossPhases = playersData[0].bossPhases || [];

        const maxDuration = Math.max(...playersData.map(p => p.duration));
        initTimeSlider(maxDuration);
        refreshCharts();
      })
      .catch(err => {
        statusEl.textContent = 'Error: ' + err;
      });
  }

  fileInput.addEventListener('change', handleFiles);
</script>
